/**
 * CromIam
 * Cromwell's Bouncer
 *
 * OpenAPI spec version: 
 * Contact: dsde@broadinstitute.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package woodard.api

import java.text.SimpleDateFormat

import woodard.model.BackendResponse
import java.util.Date
import java.io.File
import woodard.model.LabelsResponse
import woodard.model.WorkflowAbortResponse
import woodard.model.WorkflowMetadataResponse
import woodard.model.WorkflowQueryParameter
import woodard.model.WorkflowQueryResponse
import woodard.model.WorkflowStatusResponse
import woodard.model.WorkflowSubmitResponse
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class WorkflowsApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new WorkflowsApiAsyncHelper(client, config)

  /**
   * Returns the backends supported by this Cromwell.
   * 
   *
   * @param version API Version 
   * @return BackendResponse
   */
  def apiWorkflowsVersionBackendsGet(version: String): Option[BackendResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionBackendsGetAsync(version), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns the backends supported by this Cromwell. asynchronously
   * 
   *
   * @param version API Version 
   * @return Future(BackendResponse)
   */
  def apiWorkflowsVersionBackendsGetAsync(version: String): Future[BackendResponse] = {
      helper.apiWorkflowsVersionBackendsGet(version)
  }

  /**
   * Submit a batch of new workflows for execution
   * 
   *
   * @param version API Version 
   * @param workflowInputs WDL Inputs JSON as an array 
   * @param workflowSource WDL Source. Either workflow source or workflow url is required. (optional)
   * @param workflowUrl URL which points to the workflow. Either workflow source or workflow url is required. (optional)
   * @param workflowOnHold Put workflow on hold upon submission. By default, it is taken as false. (optional)
   * @param workflowOptions Workflow Options JSON (optional)
   * @param labels Custom Labels JSON (optional)
   * @param workflowDependencies Zip file containing WDL dependencies (optional)
   * @return List[WorkflowSubmitResponse]
   */
  def apiWorkflowsVersionBatchPost(version: String, workflowInputs: File, workflowSource: Option[File] = None, workflowUrl: Option[String] = None, workflowOnHold: Option[Boolean] = None, workflowOptions: Option[File] = None, labels: Option[File] = None, workflowDependencies: Option[File] = None): Option[List[WorkflowSubmitResponse]] = {
    val await = Try(Await.result(apiWorkflowsVersionBatchPostAsync(version, workflowInputs, workflowSource, workflowUrl, workflowOnHold, workflowOptions, labels, workflowDependencies), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Submit a batch of new workflows for execution asynchronously
   * 
   *
   * @param version API Version 
   * @param workflowInputs WDL Inputs JSON as an array 
   * @param workflowSource WDL Source. Either workflow source or workflow url is required. (optional)
   * @param workflowUrl URL which points to the workflow. Either workflow source or workflow url is required. (optional)
   * @param workflowOnHold Put workflow on hold upon submission. By default, it is taken as false. (optional)
   * @param workflowOptions Workflow Options JSON (optional)
   * @param labels Custom Labels JSON (optional)
   * @param workflowDependencies Zip file containing WDL dependencies (optional)
   * @return Future(List[WorkflowSubmitResponse])
   */
  def apiWorkflowsVersionBatchPostAsync(version: String, workflowInputs: File, workflowSource: Option[File] = None, workflowUrl: Option[String] = None, workflowOnHold: Option[Boolean] = None, workflowOptions: Option[File] = None, labels: Option[File] = None, workflowDependencies: Option[File] = None): Future[List[WorkflowSubmitResponse]] = {
      helper.apiWorkflowsVersionBatchPost(version, workflowInputs, workflowSource, workflowUrl, workflowOnHold, workflowOptions, labels, workflowDependencies)
  }

  /**
   * Return the hash differential between two calls
   * 
   *
   * @param version API Version 
   * @param workflowA Workflow Id of the first workflow 
   * @param callA Call FQN (including workflow name) of the first call 
   * @param workflowB Workflow Id of the second workflow 
   * @param callB Call FQN (including workflow name) of the second call 
   * @param indexA Index of the first call (optional)
   * @param indexB Index of the second call (optional)
   * @return void
   */
  def apiWorkflowsVersionCallcachingDiffGet(version: String, workflowA: String, callA: String, workflowB: String, callB: String, indexA: Option[String] = None, indexB: Option[String] = None) = {
    val await = Try(Await.result(apiWorkflowsVersionCallcachingDiffGetAsync(version, workflowA, callA, workflowB, callB, indexA, indexB), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Return the hash differential between two calls asynchronously
   * 
   *
   * @param version API Version 
   * @param workflowA Workflow Id of the first workflow 
   * @param callA Call FQN (including workflow name) of the first call 
   * @param workflowB Workflow Id of the second workflow 
   * @param callB Call FQN (including workflow name) of the second call 
   * @param indexA Index of the first call (optional)
   * @param indexB Index of the second call (optional)
   * @return Future(void)
   */
  def apiWorkflowsVersionCallcachingDiffGetAsync(version: String, workflowA: String, callA: String, workflowB: String, callB: String, indexA: Option[String] = None, indexB: Option[String] = None) = {
      helper.apiWorkflowsVersionCallcachingDiffGet(version, workflowA, callA, workflowB, callB, indexA, indexB)
  }

  /**
   * Abort a workflow based on workflow id
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @return WorkflowAbortResponse
   */
  def apiWorkflowsVersionIdAbortPost(version: String, id: String): Option[WorkflowAbortResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionIdAbortPostAsync(version, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Abort a workflow based on workflow id asynchronously
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @return Future(WorkflowAbortResponse)
   */
  def apiWorkflowsVersionIdAbortPostAsync(version: String, id: String): Future[WorkflowAbortResponse] = {
      helper.apiWorkflowsVersionIdAbortPost(version, id)
  }

  /**
   * Add new labels or update values for existing label keys by workflow id.
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @param labels Custom labels submitted as JSON. Example: {\&quot;key-1\&quot;:\&quot;value-1\&quot;,\&quot;key-2\&quot;:\&quot;value-2\&quot;}  
   * @return LabelsResponse
   */
  def apiWorkflowsVersionIdLabelsPatch(version: String, id: String, labels: Any): Option[LabelsResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionIdLabelsPatchAsync(version, id, labels), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add new labels or update values for existing label keys by workflow id. asynchronously
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @param labels Custom labels submitted as JSON. Example: {\&quot;key-1\&quot;:\&quot;value-1\&quot;,\&quot;key-2\&quot;:\&quot;value-2\&quot;}  
   * @return Future(LabelsResponse)
   */
  def apiWorkflowsVersionIdLabelsPatchAsync(version: String, id: String, labels: Any): Future[LabelsResponse] = {
      helper.apiWorkflowsVersionIdLabelsPatch(version, id, labels)
  }

  /**
   * Query for the standard output and error of all calls in a workflow
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @return void
   */
  def apiWorkflowsVersionIdLogsGet(version: String, id: String) = {
    val await = Try(Await.result(apiWorkflowsVersionIdLogsGetAsync(version, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Query for the standard output and error of all calls in a workflow asynchronously
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @return Future(void)
   */
  def apiWorkflowsVersionIdLogsGetAsync(version: String, id: String) = {
      helper.apiWorkflowsVersionIdLogsGet(version, id)
  }

  /**
   * Query for workflow and call-level metadata for a specified workflow
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @param includeKey When specified key(s) to include from the metadata. Matches any key starting with the value. May not be used with excludeKey.  (optional)
   * @param excludeKey When specified key(s) to exclude from the metadata. Matches any key starting with the value. May not be used with includeKey.  (optional)
   * @param expandSubWorkflows When true, metadata for sub workflows will be fetched and inserted automatically in the metadata response.  (optional, default to false)
   * @return WorkflowMetadataResponse
   */
  def apiWorkflowsVersionIdMetadataGet(version: String, id: String, includeKey: Option[List[String]] = None, excludeKey: Option[List[String]] = None, expandSubWorkflows: Option[Boolean] = Option(false)): Option[WorkflowMetadataResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionIdMetadataGetAsync(version, id, includeKey, excludeKey, expandSubWorkflows), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Query for workflow and call-level metadata for a specified workflow asynchronously
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @param includeKey When specified key(s) to include from the metadata. Matches any key starting with the value. May not be used with excludeKey.  (optional)
   * @param excludeKey When specified key(s) to exclude from the metadata. Matches any key starting with the value. May not be used with includeKey.  (optional)
   * @param expandSubWorkflows When true, metadata for sub workflows will be fetched and inserted automatically in the metadata response.  (optional, default to false)
   * @return Future(WorkflowMetadataResponse)
   */
  def apiWorkflowsVersionIdMetadataGetAsync(version: String, id: String, includeKey: Option[List[String]] = None, excludeKey: Option[List[String]] = None, expandSubWorkflows: Option[Boolean] = Option(false)): Future[WorkflowMetadataResponse] = {
      helper.apiWorkflowsVersionIdMetadataGet(version, id, includeKey, excludeKey, expandSubWorkflows)
  }

  /**
   * Query for workflow outputs based on workflow id
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @return void
   */
  def apiWorkflowsVersionIdOutputsGet(version: String, id: String) = {
    val await = Try(Await.result(apiWorkflowsVersionIdOutputsGetAsync(version, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Query for workflow outputs based on workflow id asynchronously
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @return Future(void)
   */
  def apiWorkflowsVersionIdOutputsGetAsync(version: String, id: String) = {
      helper.apiWorkflowsVersionIdOutputsGet(version, id)
  }

  /**
   * Switch a workflow from &#39;On Hold&#39; to &#39;Submitted&#39; status
   * Request Cromwell to release the hold on a workflow. It will switch the status of a workflow from &#39;On Hold&#39; to &#39;Submitted&#39; so it can be picked for running. For instance this might be necessary in cases where you have submitted a workflow with workflowOnHold &#x3D; true.
   *
   * @param version API Version 
   * @param id A workflow ID 
   * @return WorkflowStatusResponse
   */
  def apiWorkflowsVersionIdReleaseHoldPost(version: String, id: String): Option[WorkflowStatusResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionIdReleaseHoldPostAsync(version, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Switch a workflow from &#39;On Hold&#39; to &#39;Submitted&#39; status asynchronously
   * Request Cromwell to release the hold on a workflow. It will switch the status of a workflow from &#39;On Hold&#39; to &#39;Submitted&#39; so it can be picked for running. For instance this might be necessary in cases where you have submitted a workflow with workflowOnHold &#x3D; true.
   *
   * @param version API Version 
   * @param id A workflow ID 
   * @return Future(WorkflowStatusResponse)
   */
  def apiWorkflowsVersionIdReleaseHoldPostAsync(version: String, id: String): Future[WorkflowStatusResponse] = {
      helper.apiWorkflowsVersionIdReleaseHoldPost(version, id)
  }

  /**
   * Query for workflow status based on workflow id
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @return WorkflowStatusResponse
   */
  def apiWorkflowsVersionIdStatusGet(version: String, id: String): Option[WorkflowStatusResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionIdStatusGetAsync(version, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Query for workflow status based on workflow id asynchronously
   * 
   *
   * @param version API Version 
   * @param id Workflow ID 
   * @return Future(WorkflowStatusResponse)
   */
  def apiWorkflowsVersionIdStatusGetAsync(version: String, id: String): Future[WorkflowStatusResponse] = {
      helper.apiWorkflowsVersionIdStatusGet(version, id)
  }

  /**
   * Submit a new workflow for execution
   * 
   *
   * @param version API Version 
   * @param workflowSource WDL Source. Either workflow source or workflow url is required. (optional)
   * @param workflowUrl URL which points to the workflow. Either workflow source or workflow url is required. (optional)
   * @param workflowInputs WDL Inputs JSON, 1 (optional)
   * @param workflowInputs2 WDL Inputs JSON, 2 (optional)
   * @param workflowInputs3 WDL Inputs JSON, 3 (optional)
   * @param workflowInputs4 WDL Inputs JSON, 4 (optional)
   * @param workflowInputs5 WDL Inputs JSON, 5 (optional)
   * @param workflowOptions Workflow Options JSON (optional)
   * @param workflowOnHold Put workflow on hold upon submission. By default, it is taken as false. (optional)
   * @param collectionName Collection name for this workflow (optional)
   * @param labels Custom Labels JSON (optional)
   * @param workflowDependencies Zip file containing WDL dependencies (optional)
   * @return WorkflowSubmitResponse
   */
  def apiWorkflowsVersionPost(version: String, workflowSource: Option[File] = None, workflowUrl: Option[String] = None, workflowInputs: Option[File] = None, workflowInputs2: Option[File] = None, workflowInputs3: Option[File] = None, workflowInputs4: Option[File] = None, workflowInputs5: Option[File] = None, workflowOptions: Option[File] = None, workflowOnHold: Option[Boolean] = None, collectionName: Option[String] = None, labels: Option[File] = None, workflowDependencies: Option[File] = None): Option[WorkflowSubmitResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionPostAsync(version, workflowSource, workflowUrl, workflowInputs, workflowInputs2, workflowInputs3, workflowInputs4, workflowInputs5, workflowOptions, workflowOnHold, collectionName, labels, workflowDependencies), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Submit a new workflow for execution asynchronously
   * 
   *
   * @param version API Version 
   * @param workflowSource WDL Source. Either workflow source or workflow url is required. (optional)
   * @param workflowUrl URL which points to the workflow. Either workflow source or workflow url is required. (optional)
   * @param workflowInputs WDL Inputs JSON, 1 (optional)
   * @param workflowInputs2 WDL Inputs JSON, 2 (optional)
   * @param workflowInputs3 WDL Inputs JSON, 3 (optional)
   * @param workflowInputs4 WDL Inputs JSON, 4 (optional)
   * @param workflowInputs5 WDL Inputs JSON, 5 (optional)
   * @param workflowOptions Workflow Options JSON (optional)
   * @param workflowOnHold Put workflow on hold upon submission. By default, it is taken as false. (optional)
   * @param collectionName Collection name for this workflow (optional)
   * @param labels Custom Labels JSON (optional)
   * @param workflowDependencies Zip file containing WDL dependencies (optional)
   * @return Future(WorkflowSubmitResponse)
   */
  def apiWorkflowsVersionPostAsync(version: String, workflowSource: Option[File] = None, workflowUrl: Option[String] = None, workflowInputs: Option[File] = None, workflowInputs2: Option[File] = None, workflowInputs3: Option[File] = None, workflowInputs4: Option[File] = None, workflowInputs5: Option[File] = None, workflowOptions: Option[File] = None, workflowOnHold: Option[Boolean] = None, collectionName: Option[String] = None, labels: Option[File] = None, workflowDependencies: Option[File] = None): Future[WorkflowSubmitResponse] = {
      helper.apiWorkflowsVersionPost(version, workflowSource, workflowUrl, workflowInputs, workflowInputs2, workflowInputs3, workflowInputs4, workflowInputs5, workflowOptions, workflowOnHold, collectionName, labels, workflowDependencies)
  }

  /**
   * Query workflows by start dates, end dates, names, ids, or statuses.
   * 
   *
   * @param version API Version 
   * @param start Returns only workflows with an equal or later start datetime.  Can be specified at most once. If both start and end date are specified, start date must be before or equal to end date.  (optional)
   * @param end Returns only workflows with an equal or earlier end datetime.  Can be specified at most once. If both start and end date are specified, start date must be before or equal to end date.  (optional)
   * @param status Returns only workflows with the specified status.  If specified multiple times, returns workflows in any of the specified statuses.  (optional)
   * @param name Returns only workflows with the specified name.  If specified multiple times, returns workflows with any of the specified names.  (optional)
   * @param id Returns only workflows with the specified workflow id.  If specified multiple times, returns workflows with any of the specified workflow ids.  (optional)
   * @return WorkflowQueryResponse
   */
  def apiWorkflowsVersionQueryGet(version: String, start: Option[Date] = None, end: Option[Date] = None, status: Option[List[String]] = None, name: Option[List[String]] = None, id: Option[List[String]] = None): Option[WorkflowQueryResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionQueryGetAsync(version, start, end, status, name, id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Query workflows by start dates, end dates, names, ids, or statuses. asynchronously
   * 
   *
   * @param version API Version 
   * @param start Returns only workflows with an equal or later start datetime.  Can be specified at most once. If both start and end date are specified, start date must be before or equal to end date.  (optional)
   * @param end Returns only workflows with an equal or earlier end datetime.  Can be specified at most once. If both start and end date are specified, start date must be before or equal to end date.  (optional)
   * @param status Returns only workflows with the specified status.  If specified multiple times, returns workflows in any of the specified statuses.  (optional)
   * @param name Returns only workflows with the specified name.  If specified multiple times, returns workflows with any of the specified names.  (optional)
   * @param id Returns only workflows with the specified workflow id.  If specified multiple times, returns workflows with any of the specified workflow ids.  (optional)
   * @return Future(WorkflowQueryResponse)
   */
  def apiWorkflowsVersionQueryGetAsync(version: String, start: Option[Date] = None, end: Option[Date] = None, status: Option[List[String]] = None, name: Option[List[String]] = None, id: Option[List[String]] = None): Future[WorkflowQueryResponse] = {
      helper.apiWorkflowsVersionQueryGet(version, start, end, status, name, id)
  }

  /**
   * Query workflows by start dates, end dates, names, ids, or statuses.
   * 
   *
   * @param version API version 
   * @param parameters Same query parameters as GET /query endpoint, submitted as a json list. Example: [{\&quot;status\&quot;:\&quot;Success\&quot;},{\&quot;status\&quot;:\&quot;Failed\&quot;}]  
   * @return WorkflowQueryResponse
   */
  def apiWorkflowsVersionQueryPost(version: String, parameters: List[WorkflowQueryParameter]): Option[WorkflowQueryResponse] = {
    val await = Try(Await.result(apiWorkflowsVersionQueryPostAsync(version, parameters), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Query workflows by start dates, end dates, names, ids, or statuses. asynchronously
   * 
   *
   * @param version API version 
   * @param parameters Same query parameters as GET /query endpoint, submitted as a json list. Example: [{\&quot;status\&quot;:\&quot;Success\&quot;},{\&quot;status\&quot;:\&quot;Failed\&quot;}]  
   * @return Future(WorkflowQueryResponse)
   */
  def apiWorkflowsVersionQueryPostAsync(version: String, parameters: List[WorkflowQueryParameter]): Future[WorkflowQueryResponse] = {
      helper.apiWorkflowsVersionQueryPost(version, parameters)
  }

}

class WorkflowsApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def apiWorkflowsVersionBackendsGet(version: String)(implicit reader: ClientResponseReader[BackendResponse]): Future[BackendResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/backends")
      replaceAll("\\{" + "version" + "\\}", version.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionBackendsGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionBatchPost(version: String,
    workflowInputs: File,
    workflowSource: Option[File] = None,
    workflowUrl: Option[String] = None,
    workflowOnHold: Option[Boolean] = None,
    workflowOptions: Option[File] = None,
    labels: Option[File] = None,
    workflowDependencies: Option[File] = None
    )(implicit reader: ClientResponseReader[List[WorkflowSubmitResponse]]): Future[List[WorkflowSubmitResponse]] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/batch")
      replaceAll("\\{" + "version" + "\\}", version.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionBatchPost")

    if (workflowInputs == null) throw new Exception("Missing required parameter 'workflowInputs' when calling WorkflowsApi->apiWorkflowsVersionBatchPost")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionCallcachingDiffGet(version: String,
    workflowA: String,
    callA: String,
    workflowB: String,
    callB: String,
    indexA: Option[String] = None,
    indexB: Option[String] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/callcaching/diff")
      replaceAll("\\{" + "version" + "\\}", version.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionCallcachingDiffGet")

    if (workflowA == null) throw new Exception("Missing required parameter 'workflowA' when calling WorkflowsApi->apiWorkflowsVersionCallcachingDiffGet")

    if (callA == null) throw new Exception("Missing required parameter 'callA' when calling WorkflowsApi->apiWorkflowsVersionCallcachingDiffGet")

    if (workflowB == null) throw new Exception("Missing required parameter 'workflowB' when calling WorkflowsApi->apiWorkflowsVersionCallcachingDiffGet")

    if (callB == null) throw new Exception("Missing required parameter 'callB' when calling WorkflowsApi->apiWorkflowsVersionCallcachingDiffGet")

    queryParams += "workflowA" -> workflowA.toString
    queryParams += "callA" -> callA.toString
    indexA match {
      case Some(param) => queryParams += "indexA" -> param.toString
      case _ => queryParams
    }
    queryParams += "workflowB" -> workflowB.toString
    queryParams += "callB" -> callB.toString
    indexB match {
      case Some(param) => queryParams += "indexB" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionIdAbortPost(version: String,
    id: String)(implicit reader: ClientResponseReader[WorkflowAbortResponse]): Future[WorkflowAbortResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/{id}/abort")
      replaceAll("\\{" + "version" + "\\}", version.toString)
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionIdAbortPost")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling WorkflowsApi->apiWorkflowsVersionIdAbortPost")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionIdLabelsPatch(version: String,
    id: String,
    labels: Any)(implicit reader: ClientResponseReader[LabelsResponse], writer: RequestWriter[Any]): Future[LabelsResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/{id}/labels")
      replaceAll("\\{" + "version" + "\\}", version.toString)
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionIdLabelsPatch")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling WorkflowsApi->apiWorkflowsVersionIdLabelsPatch")


    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(labels))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionIdLogsGet(version: String,
    id: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/{id}/logs")
      replaceAll("\\{" + "version" + "\\}", version.toString)
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionIdLogsGet")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling WorkflowsApi->apiWorkflowsVersionIdLogsGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionIdMetadataGet(version: String,
    id: String,
    includeKey: Option[List[String]] = None,
    excludeKey: Option[List[String]] = None,
    expandSubWorkflows: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[WorkflowMetadataResponse]): Future[WorkflowMetadataResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/{id}/metadata")
      replaceAll("\\{" + "version" + "\\}", version.toString)
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionIdMetadataGet")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling WorkflowsApi->apiWorkflowsVersionIdMetadataGet")

    includeKey match {
      case Some(param) => queryParams += "includeKey" -> param.toString
      case _ => queryParams
    }
    excludeKey match {
      case Some(param) => queryParams += "excludeKey" -> param.toString
      case _ => queryParams
    }
    expandSubWorkflows match {
      case Some(param) => queryParams += "expandSubWorkflows" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionIdOutputsGet(version: String,
    id: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/{id}/outputs")
      replaceAll("\\{" + "version" + "\\}", version.toString)
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionIdOutputsGet")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling WorkflowsApi->apiWorkflowsVersionIdOutputsGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionIdReleaseHoldPost(version: String,
    id: String)(implicit reader: ClientResponseReader[WorkflowStatusResponse]): Future[WorkflowStatusResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/{id}/releaseHold")
      replaceAll("\\{" + "version" + "\\}", version.toString)
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionIdReleaseHoldPost")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling WorkflowsApi->apiWorkflowsVersionIdReleaseHoldPost")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionIdStatusGet(version: String,
    id: String)(implicit reader: ClientResponseReader[WorkflowStatusResponse]): Future[WorkflowStatusResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/{id}/status")
      replaceAll("\\{" + "version" + "\\}", version.toString)
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionIdStatusGet")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling WorkflowsApi->apiWorkflowsVersionIdStatusGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionPost(version: String,
    workflowSource: Option[File] = None,
    workflowUrl: Option[String] = None,
    workflowInputs: Option[File] = None,
    workflowInputs2: Option[File] = None,
    workflowInputs3: Option[File] = None,
    workflowInputs4: Option[File] = None,
    workflowInputs5: Option[File] = None,
    workflowOptions: Option[File] = None,
    workflowOnHold: Option[Boolean] = None,
    collectionName: Option[String] = None,
    labels: Option[File] = None,
    workflowDependencies: Option[File] = None
    )(implicit reader: ClientResponseReader[WorkflowSubmitResponse]): Future[WorkflowSubmitResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}")
      replaceAll("\\{" + "version" + "\\}", version.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionPost")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionQueryGet(version: String,
    start: Option[Date] = None,
    end: Option[Date] = None,
    status: Option[List[String]] = None,
    name: Option[List[String]] = None,
    id: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[WorkflowQueryResponse]): Future[WorkflowQueryResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/query")
      replaceAll("\\{" + "version" + "\\}", version.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionQueryGet")

    start match {
      case Some(param) => queryParams += "start" -> param.toString
      case _ => queryParams
    }
    end match {
      case Some(param) => queryParams += "end" -> param.toString
      case _ => queryParams
    }
    status match {
      case Some(param) => queryParams += "status" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    id match {
      case Some(param) => queryParams += "id" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiWorkflowsVersionQueryPost(version: String,
    parameters: List[WorkflowQueryParameter])(implicit reader: ClientResponseReader[WorkflowQueryResponse], writer: RequestWriter[List[WorkflowQueryParameter]]): Future[WorkflowQueryResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workflows/{version}/query")
      replaceAll("\\{" + "version" + "\\}", version.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (version == null) throw new Exception("Missing required parameter 'version' when calling WorkflowsApi->apiWorkflowsVersionQueryPost")

    if (parameters == null) throw new Exception("Missing required parameter 'parameters' when calling WorkflowsApi->apiWorkflowsVersionQueryPost")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(parameters))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
